# 作用域的实现机制 

var name = 'hello'
在我们看来，这只是一个声明语句。但是在 JS 引擎眼里，它却包含了两个声明：
var name (编译时处理)
name = 'hello'(运行时处理)


编译阶段： 这时登场的是一个叫 编译器 的家伙。编译器会找遍当前作用域，看看是不是已经有一个叫 name 的家伙了。如果有，那么就忽略 var name 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 name。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段

执行阶段： 这时登场的就是大家常常听到的 JS 引擎 了。JS 引擎在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的家伙。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有。如果最终仍然找不到 name 变量，引擎就会抛出一个异常。



这里出现了一个有趣的东西，就是我们引擎的查找过程 —— 何谓探出头去？何谓 “外面” 呢？这就引出了我们 JS 作用域里一个非常重要的概念 —— 作用域链。


在 JS 世界中，目前已经有了三种作用域：
# 全局作用域
# 函数作用域
# 块作用域

*在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而像 add 这样引用了自由变量的函数，就叫闭包。*



# 查询变量的两种方式

变量出现在赋值操作的左侧时(LHS)
name = 'hello';
LHS 意味着 *变量赋值或写入内存*


变量出现在赋值操作的右侧时(RHS)
var myName = name
console.log(name)
RHS 意味着 *变量查找或从内存中读取 强调的是读这个动作，查询的是变量的内容*