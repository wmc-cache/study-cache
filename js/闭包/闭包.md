# 作用域的实现机制 

var name = 'hello'
在我们看来，这只是一个声明语句。但是在 JS 引擎眼里，它却包含了两个声明：
var name (编译时处理)
name = 'hello'(运行时处理)


编译阶段： 这时登场的是一个叫 编译器 的家伙。编译器会找遍当前作用域，看看是不是已经有一个叫 name 的家伙了。如果有，那么就忽略 var name 这个声明，继续编译下去；如果没有，则在当前作用域里新增一个 name。然后，编译器会为引擎生成运行时所需要的代码，程序就进入了执行阶段

执行阶段： 这时登场的就是大家常常听到的 JS 引擎 了。JS 引擎在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的家伙。如果能找到，那么万事大吉，我来给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有。如果最终仍然找不到 name 变量，引擎就会抛出一个异常。



这里出现了一个有趣的东西，就是我们引擎的查找过程 —— 何谓探出头去？何谓 “外面” 呢？这就引出了我们 JS 作用域里一个非常重要的概念 —— 作用域链(作用域套作用域)。


在 JS 世界中，目前已经有了三种作用域：
# 全局作用域
# 函数作用域
# 块作用域

``` js
function addABC(){
  var a = 1,b = 2;
  
  function add(){
    return a+b+c;
  }
  return add;
}

var c = 3

var globalAdd = addABC()

console.log(globalAdd()) // 6

```

*像 a、b、c 这样在函数中被使用，但它既不是函数参数、也不是函数的局部变量，而是一个不属于当前作用域的变量，此时它相对于当前作用域来说，就是一个自由变量。而像 add 这样引用了自由变量的函数，就叫闭包。*



*闭包产生的根本原因是词法作用域与函数是第一公民相互作用而产生的自然现象*


# 查询变量的两种方式

变量出现在赋值操作的左侧时(LHS)
name = 'hello';
LHS 意味着 *变量赋值或写入内存*


变量出现在赋值操作的右侧时(RHS)
var myName = name
console.log(name)
RHS 意味着 *变量查找或从内存中读取 强调的是读这个动作，查询的是变量的内容*




*作用域其实就是当前所处的执行上下文*
# 执行上下文主要分为三类：

全局上下文 —— 全局代码所处的环境，不在函数中的代码都在全局执行上下文中
函数上下文 —— 在函数调用时创建的上下文
Eval 执行上下文 —— 运行 Eval 函数中的代码时所创建的环境，Eval 被前端诟病多年，时下对 Eval 感兴趣的人非常少了

*在执行上下文的创建阶段，跟着被创建的还有作用域链！这个作用域链在函数中以内部属性的形式存在，在函数定义时，其对应的父变量对象就会被记录到这个内部属性里。闭包正是通过这一层作用域链的关系，实现了对父作用域执行上下文信息的保留。*